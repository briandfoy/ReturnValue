Everyone wants to parse HTML, and many people reach for a regular expression to do that. Although you can <a href="http://stackoverflow.com/a/4234491/2766176">use a regex to parse HTML</a>, it's not as fun as my latest favorite way: <a href="http://www.metacpan.org/module/Mojo::DOM">Mojo::DOM</a> with CSS3 selectors. I find this much easier than trying to remember XPATH and I get to play with Mojo.

The DOM is <a href="http://www.w3.org/DOM/">"Document Object Module"</a>. Something behind the scenes parses and organizes the
information and allows me to query it with questions such as "find all the <code>a</code> tags inside a <code>div</code> tag", or "find all the tags of a particular class". I don't manipulate the text myself.

If I'm using <a href="http://mojolicio.us/perldoc/Mojo/UserAgent">Mojo::UserAgent</a>, I can get a DOM object from the response object from the transaction: 

<pre class="prettyprint lang-perl"><code>use Mojo::UserAgent;
my $ua = Mojo::UserAgent->new;

my $dom = $ua->get( 'http://search.cpan.org/~bdfoy/' )
	->res
	->dom;
</code></pre>

The Mojo method-chaining style with one method per line shows its strengths as I get into more complicated tasks later.

I don't have to make a request to get a DOM object. I'm often presented with HTML files to parse with no server to give them to me. Depending on the tractability of the task, I might hand edit it to remove the parts I don't want to think about then use a regex to handle the rest. That way, I don't have to do a lot of work to save state and know where I am in the document. With a DOM, that's not a problem.

In the first example, I fetched <code>http://search.cpan.org/~bdfoy/'</code>, my author page at <a href="http://search.cpan.org/">CPAN Search</a>. I'll start with that HTML, assuming I already have it in a string.

<pre class="prettyprint lang-perl"><code>use Mojo::DOM;

my $string = ...;

my $dom = Mojo::DOM->new( $string );

my $module_list = $dom
	->find('a')
	->join("\n");

print $module_list;
</code></pre>

Once I have the <code>$dom</code> object, I can use <code>find</code> to select elements. I give <code>find</code> a <a href="http://mojolicio.us/perldoc/Mojo/DOM/CSS#SELECTORS">CSS3 selector</a>, in this case just <code>a</code> to find all the anchor links. <code>find</code> returns a <a href=="http://mojolicio.us/perldoc/Mojo/Collection">Mojo::Collection</a> object, a fancy way to store a list and do things do it. The Mojolicious style makes heavy use of method chaining so it needs a way to call methods on the result. In this example, I merely <code>join</code> the elements with a newline:


<pre class="pp"><code><span class="nocode"><a href="/"><img alt="CPAN" src="http://st.pimg.net/tucs/img/cpan_banner.png"></a>
<a href="/">Home</a>
<a href="/author/">Authors</a>
<a href="/recent">Recent</a>
<a href="http://log.perl.org/cpansearch/">News</a>
<a href="/mirror">Mirrors</a>
<a href="/faq.html">FAQ</a>
<a href="/feedback">Feedback</a>
<a href="Acme-BDFOY-0.01/">Acme-BDFOY-0.01</a>
<a href="/CPAN/authors/id/B/BD/BDFOY/Acme-BDFOY-0.01.tar.gz">Download</a>
<a href="/src/BDFOY/Acme-BDFOY-0.01/">Browse</a>
</span></code></pre>

That's a good start, but I extracted all of the links. I want to limit it to the links to my distributions. Looking at the HTML, I see that the link I want is in the first <code>td</code> tag in a <code>tr</code>:

<pre class="pp"><code><span class="nocode"><tr class=s>
    <td><a href="Data-Constraint-1.17/">Data-Constraint-1.17</a></td>
    <td>prototypical value checking</td>
    <td><small>[<a href="/CPAN/authors/id/B/BD/BDFOY/Data-Constraint-1.17.tar.gz">Download</a>]&nbsp;[<a
      href="/src/BDFOY/Data-Constraint-1.17/">Browse</a>]</small></td>
    <td nowrap>26 Aug 2014</td>
   </tr>
</span></code></pre>

I change my selector to look for the first anchor in the first table cell in a table row:

<pre class="prettyprint lang-perl"><code>
my $module_list = $dom
	->find('tr td:first-child a:first-child')
	->join("\n");
</code></pre>

Now I have a list of the links I want, but with the anchor HTML and text:

<pre class="pp"><code><span class="nocode"><a href="Acme-BDFOY-0.01/">Acme-BDFOY-0.01</a>
<a href="Apache-Htaccess-1.4/">Apache-Htaccess-1.4</a>
<a href="Apache-iTunes-0.11/">Apache-iTunes-0.11</a>
<a href="App-Module-Lister-0.15/">App-Module-Lister-0.15</a>
<a href="App-PPI-Dumper-1.02/">App-PPI-Dumper-1.02</a>
</span></code></pre>

I still have a bit of work to do. I want to extract the value of the <code>href</code> attribute. I can do that with the <code>map</code> method from <a href="http://mojolicio.us/perldoc/Mojo/Collection">Mojo::Collection</a>:

<pre class="prettyprint lang-perl"><code>my $module_list = $dom
	->find('tr td:first-child a:first-child')
	->map( attr => 'href' )
	->join("\n");
</code></pre>

Each element in the collection is actually a <a href="http://mojolicio.us/perldoc/Mojo/DOM">Mojo::DOM</a> object. The first argument to <code>map</code> is the method to call on each element and the remaining arguments pass through to that method. In this case, I'm calling <code>attr('href')</code> on each object. Now I mostly have the values I want:

<pre class="pp"><code><span class="nocode">Acme-BDFOY-0.01/
Apache-Htaccess-1.4/
Apache-iTunes-0.11/
App-Module-Lister-0.15/
App-PPI-Dumper-1.02/
</span></code></pre>

I don't want that trailing slash. I can use another <code>map</code>, but with an anonymous subroutine. The result of the subroutine replaces the element in the collection. I use the <a href="http://www.effectiveperlprogramming.com/2010/09/use-the-r-substitution-flag-to-work-on-a-copy/"><code>/r</code> of the substitution operator to return the modified string</a> instead of the number of substitutions (best Perl enhancement ever):

<pre class="prettyprint lang-perl"><code>use v5.14;

my $module_list = $dom
	->find('tr td:first-child a:first-child')
	->map( attr => 'href' )
	->map( sub { s|/\z||r } )
	->join("\n");
</code></pre>

Now I have my list of distributions:

<pre class="pp"><code><span class="nocode">Acme-BDFOY-0.01
Apache-Htaccess-1.4
Apache-iTunes-0.11
App-Module-Lister-0.15
App-PPI-Dumper-1.02
</span></code></pre>

That's still as one string since I ended the method chain with <code>join("\n")</code>. To get a list, I use <code>each</code> to get the list, which I join myself later:

<pre class="prettyprint lang-perl"><code>my @module_list = $dom
	->find('tr td:first-child a:first-child')
	->map( attr => 'href' )
	->map( sub { s|/\z||r } )
	->each;

print join "\n", @module_list;
</code></pre>

I can get even fancier. Instead of the distribution name with the version, I can break it up with <a href="http://www.metacpan.org/module/CPAN::DistnameInfo">CPAN::DistnameInfo</a>. I'll turn every found link into a tuple of name and version. Since that module wants to deal with a distribution filename, I tack on <i>.tar.gz</i> to make it work out:

<pre class="prettyprint lang-perl"><code>use Data::Printer;
use CPAN::DistnameInfo;

my $dom = Mojo::DOM->new( $string );

my @module_list = $dom
	->find('tr td:first-child a:first-child')
	->map( attr => 'href' )
	->map( sub { s|/\z||r } )
	->map( sub { 
		my $d = CPAN::DistnameInfo->new( "$_.tar.gz" );
		[ map { $d->$_() } qw(dist version) ];
		 } )
	->each;

p @module_list;
</code></pre>

The <code>each</code> extracts each element from the collection and returns it. I use <a href="">Data::Printer</a> to display the array:

<pre class="pp"><code><span class="nocode">[
    [0]   [
        [0] "Acme-BDFOY",
        [1] 0.01
    ],
    [1]   [
        [0] "Apache-Htaccess",
        [1] 1.4
    ],
    [2]   [
        [0] "Apache-iTunes",
        [1] 0.11
    ],
    [3]   [
        [0] "App-Module-Lister",
        [1] 0.15
    ],
</span></code></pre>

If I want only the distributions that are development versions, I can use <a href="http://mojolicio.us/perldoc/Mojo/Collection">Mojo::Collection</a>'s <code>grep</code>:

<pre class="prettyprint lang-perl"><code>my @module_list = $dom
	->find('tr td:first-child a:first-child')
	->map( attr => 'href' )
	->map( sub { s|/\z||r } )
	->map( sub { 
		my $d = CPAN::DistnameInfo->new( "$_.tar.gz" );
		[ map { $d->$_() } qw(dist version) ];
		 } )
	->grep( sub { $_->[-1] =~ /_/ } )
	->each;
</code></pre>

The <code>grep</code> selects each element of the collection for which the subroutine returns a true value:

<pre class="pp"><code><span class="nocode">[
    [0]  [
        [0] "Brick",
        [1] "0.227_01"
    ],
    [1]  [
        [0] "Distribution-Guess-BuildSystem",
        [1] "0.12_02"
    ],
    [2]  [
        [0] "File-Fingerprint",
        [1] "0.10_02"
    ],
    [3]  [
        [0] "Geo-GeoNames",
        [1] "1.01_01"
    ],
</span></code></pre>

That's the process. No HTML shows up in my code. The rest is figuring out how to select the particular element that I want.
